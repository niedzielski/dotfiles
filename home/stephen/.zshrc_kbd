#!/usr/bin/env zsh
# ------------------------------------------------------------------------------
# .zshrc_kbd
# Keyboard shortcuts for Windows-like behavior. You get highlight, cut and
# paste, word jumps, and more!
# Copyright 2009 - 2013 Stephen Niedzielski. Licensed under GPLv3.

# ------------------------------------------------------------------------------
# Enter Selection Mode

# Selection color.
zle_highlight=(region:bg=blue)

# Enable or extend selection on s-left / right and c-s-left / right.
_hl_set_bch() { [ $REGION_ACTIVE -eq 0 ] && zle set-mark-command; zle backward-char }; zle -N _hl_set_bch; bindkey "$terminfo[kLFT]" _hl_set_bch # s-left
_hl_set_bwd() { [ $REGION_ACTIVE -eq 0 ] && zle set-mark-command; zle backward-word }; zle -N _hl_set_bwd; bindkey '^[[1;6D'         _hl_set_bwd # c-s-left
_hl_set_fch() { [ $REGION_ACTIVE -eq 0 ] && zle set-mark-command; zle forward-char  }; zle -N _hl_set_fch; bindkey "$terminfo[kRIT]" _hl_set_fch # s-right
_hl_set_fwd() { [ $REGION_ACTIVE -eq 0 ] && zle set-mark-command; zle forward-word  }; zle -N _hl_set_fwd; bindkey '^[[1;6C'         _hl_set_fwd # c-s-right
# TODO: s-up and s-down for multi-line commands.
# Unavailable (?): s-home, c-s-home, s-end, or c-s-end.

# ------------------------------------------------------------------------------
# Exit Selection Mode

# Backspace and delete.
_hl_clr_bs()  { [ $REGION_ACTIVE -eq 1 ] && zle kill-region || zle backward-delete-char }; zle -N _hl_clr_bs  ; bindkey "$terminfo[kbs]"   _hl_clr_bs   # backspace
_hl_clr_cbs() { [ $REGION_ACTIVE -eq 1 ] && zle kill-region || zle backward-delete-word }; zle -N _hl_clr_cbs ; bindkey '^\'               _hl_clr_cbs  # c-\ (can't do c-backspace)
_hl_clr_del() { [ $REGION_ACTIVE -eq 1 ] && zle kill-region || zle delete-char          }; zle -N _hl_clr_del ; bindkey "$terminfo[kdch1]" _hl_clr_del  # delete
_hl_clr_cdel(){ [ $REGION_ACTIVE -eq 1 ] && zle kill-region || zle delete-word          }; zle -N _hl_clr_cdel; bindkey '^[[3;5~'          _hl_clr_cdel # c-delete

# Left and right.
_hl_clr_bch() { zle backward-char; REGION_ACTIVE=0 }; zle -N _hl_clr_bch; bindkey "$terminfo[kcub1]" _hl_clr_bch # left
_hl_clr_bwd() { zle backward-word; REGION_ACTIVE=0 }; zle -N _hl_clr_bwd; bindkey '^[[1;5D'          _hl_clr_bwd # ctrl-left
_hl_clr_fch() { zle forward-char ; REGION_ACTIVE=0 }; zle -N _hl_clr_fch; bindkey "$terminfo[kcuf1]" _hl_clr_fch # right
_hl_clr_fwd() { zle forward-word ; REGION_ACTIVE=0 }; zle -N _hl_clr_fwd; bindkey '^[[1;5C'          _hl_clr_fwd # ctrl-right

# Exit cases for some common keystrokes.
# TODO: is there a way to implement a default bindkey? If not, how can we get
# the current key pressed and just have one function?
# TODO: having trouble getting -, ", \ to work... Consider printf %q.
#for i in ' ' \! \# \$ % \& \' \( \) \* \+ , {.-\[} \] \^ _ \\\` {a-~}; do
#  declare f="_hl_clr_$(printf %d "'$i'")"

  # Inject $i's value into the function by evaluating it.
#  eval "$(echo "$f() { [[ \$REGION_ACTIVE -eq 1 ]] && zle kill-region; LBUFFER+=\"$i\" }")"

#  zle -N $f
#  bindkey "$i" $f
#done

# ------------------------------------------------------------------------------
# Copy
case "$OSTYPE" in
     cygwin) _copy() { echo -n "$1"|putclip      } ;;
  linux-gnu) _copy() { echo -n "$1"|xclip -sel c } ;;
    darwin*) _copy() { echo -n "$1"|pbcopy       } ;;
          *) echo "Unknown OSTYPE \"$OSTYPE\"." >&2 ;;
esac

_hl_copy()
{
  if [ $REGION_ACTIVE -eq 1 ]
  then
    if [ $CURSOR -lt $MARK ]
    then
       _copy "$BUFFER[(($CURSOR+1)),$MARK]";
    else
       _copy "$BUFFER[(($MARK+1)),$CURSOR]";
    fi
  fi
}
zle -N _hl_copy
bindkey '^B' _hl_copy # c-b (can't do c-c)

# ------------------------------------------------------------------------------
# Cut
_hl_cut()
{
  if [ $REGION_ACTIVE -eq 1 ]
  then
    zle kill-region # this seems to be really slow.
    _copy "$CUTBUFFER"
  fi
}
zle -N _hl_cut
bindkey '^X' _hl_cut # c-x

# ------------------------------------------------------------------------------
# Paste
case "$OSTYPE" in
     cygwin) _paste() { LBUFFER+="$(getclip -u)"      } ;;
  linux-gnu) _paste() { LBUFFER+="$(xclip -sel c -o)" } ;;
    darwin*) _paste() { LBUFFER+="$(pbpaste)"         } ;;
          *) echo "Unknown OSTYPE \"$OSTYPE\"." >&2 ;;
esac
zle -N _paste
bindkey '^V' _paste # c-v

# ------------------------------------------------------------------------------
# Un/redo

bindkey '^Z' undo # c-z
bindkey '^Y' redo # c-y

# ------------------------------------------------------------------------------
# Explorer Style Directory Navigation

_back_widget() { pushd +1 &> /dev/null; zle reset-prompt }; zle -N _back_widget
_fwd_widget () { pushd -0 &> /dev/null; zle reset-prompt }; zle -N _fwd_widget
_up_widget  () { cd ..    &> /dev/null; zle reset-prompt }; zle -N _up_widget
_pop_widget () { popd     &> /dev/null; zle reset-prompt }; zle -N _pop_widget

# TODO: figure out proper way to do this with terminfo.
if [[ "$OSTYPE" == "cygwin"  ]]
then
  bindkey '^[^[[D' _back_widget # a-left
  bindkey '^[^[[C' _fwd_widget  # a-right
  bindkey '^[^[[A' _up_widget   # a-up (won't do backspace)
else
  bindkey '^[[1;3D' _back_widget # a-left
  bindkey '^[[1;3C' _fwd_widget  # a-right
  bindkey '^[[1;3A' _up_widget   # a-up (won't do backspace)
  bindkey "\e[1;3B" _pop_widget
fi

# ------------------------------------------------------------------------------
# Miscellaneous Keyboard Shortcuts

# If text is selected, quote it. Otherwise, quote the whole line.
_hl_quote_widget()
{
  if [ $REGION_ACTIVE -eq 1 ]
  then
    zle quote-region
  else
    zle quote-line
  fi
}
zle -N _hl_quote_widget
bindkey '^k' _hl_quote_widget

bindkey '^[[1;5A' history-incremental-pattern-search-backward # c-up
bindkey '^[[1;5B' history-incremental-pattern-search-forward  # c-down
bindkey '^L'      clear-screen                                # c-l

# ------------------------------------------------------------------------------
# Completion

#autoload -U compinit
#compinit -C

# case-insensitive (all),partial-word and then substring completion
#http://forums.macosxhints.com/archive/index.php/t-6493.html
#zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}' 'r:|[._-]=* r:|=*' 'l:|=* r:|=*'

# Enable case-insensitive completion.
#zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}'


# Tab completion.
#bindkey '\t' expand-or-complete-prefix # tab
# TODO: s-tab.

# TODO: s-enter is next line down.
# TODO: mouse interaction



# Stop on error.
setopt err_return

# Fail if undefined variables are used.
set -u

# Prohibit redirection overwriting >.
set -C



# This variable describes non-alphanumeric characters considered words (opposite
# of delimiters) for the prompt. I like to break at each directory in a path, so
# I eliminate the forward slash from this set:
WORDCHARS=${WORDCHARS:s#/#}
WORDCHARS=${WORDCHARS:s#.#}
WORDCHARS=${WORDCHARS:s#-#}
WORDCHARS=${WORDCHARS:s#_#}
WORDCHARS=${WORDCHARS:s#=#}
