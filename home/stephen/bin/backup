#!/usr/bin/env bash
set -euo pipefail

# Check with (consider adding -q):
#
#   time diff -r /media/stephen/daily20210520/archive/archive-2021-05-26-23-08/home/stephen /home/stephen &> ~/desk/diff.txt

# Print the current time like `2020-12-31-23-59`.
timestamp() { date +%F-%H-%M; }

source_dirs=(${source_dirs:-"$HOME" /etc /usr})
for source_dir in "${source_dirs[@]}"; do
  if ! [ -d "$source_dir" ]; then
    >&2 echo "Source directory, \"$source_dir\", does not exist."
    exit 1
  fi
done

exclude_dirs=(${exclude_dirs:-"$HOME/.local/share/Trash"})
for exclude_dir in "${exclude_dirs[@]}"; do
  if ! [ -d "$exclude_dir" ]; then
    >&2 echo "Exclude directory, \"$exclude_dir\", does not exist."
    exit 1
  fi
done

# Destination starts with `archive-`.
destination_stem="${destination_stem:-archive-}"

# Update this destination as needed. I usually just make a new empty
# archive directory when changing drives.
destination_base_dir="${destination_base_dir:-/media/stephen/daily20210520/archive}"
if ! [ -d "$destination_base_dir" ]; then
  >&2 echo "Destination directory, \"$destination_base_dir\", does not exist."
  exit 1
fi

# The last updated directory with the matching stem in the base
# directory. I usually just make an archive/archive-null directory when
# changing drives. After the script runs for the first time, I delete
# it.
link_dir="${link_dir:-$(ls -td "${destination_base_dir}/${destination_stem}"*/ | sed '1 s%/$%%; q')}"
if ! [ -d "$link_dir" ]; then
  >&2 echo "Hard link source directory, \"$link_dir\", does not exist."
  exit 1
fi

destination_dir="${destination_dir:-${destination_base_dir}/${destination_stem}$(timestamp)}"

package_dir="${package_dir:-$destination_dir/packages}"

read -p "Ready to copy from (${source_dirs[*]}), excluding (${exclude_dirs[*]}), to \"${destination_dir}\" with hard links to \"$link_dir\". Additionally, a screenshot will be taken immediately and packages recorded. Execute '#rm -rf \"${destination_dir}\"' if the copy is aborted otherwise the next link directory will be incomplete. <Enter> to continue, <ctrl-c> to abort: "

mkdir -p "$destination_dir"
import -screen -window root "$destination_dir/desktop.png"

mkdir -p "$package_dir"
dpkg -l &> "$package_dir/dpkg.txt"
snap list &> "$package_dir/snap.txt"
code --list-extensions &> "$package_dir/code.txt"
npm -g ls --depth=0 &> "$package_dir/npm.txt" || :
ghc-pkg list &> "$package_dir/ghc-pkg.txt" || :
pip freeze &> "$package_dir/pip.txt" || :
gem list -a &> "$package_dir/gem.txt" || :
apm list &> "$package_dir/apm.txt" || :
cabal list --installed &> "$package_dir/cabal.txt" || :
go list ... &> "$package_dir/go.txt" || :
du -bs "${source_dirs[@]}" &> "$package_dir/du.txt" || :
top -bn1 -w512 &> "$package_dir/top.txt" || :
xwininfo -tree -root -all &> "$package_dir/xwininfo.txt" || :
# [todo] Flatpak, Sublime Text.

# This won't check for hard links on the source (`-H`). Rsync says this is a big
# performance hit, I didn't know if there were caveats when using `--link-dest`,
# and I don't think it will actually offer many gains given I don't consciously
# make hard links in my source files and `--link-dest` is checking the last sync
# anyway.
#
# Extended-attributes (`-X`) and ACLs (`-A`) are also not copied. These could be
# added but I don't consciously use them in my source files and I'm unsure what
# the implications of copying them are unfortunately.
#
# No compression and no partials since the transfer is local and I'm assuming
# these have a performance cost.
#
# No deletion since I always copy to a new directory.
err=0
time rsync \
  -aR \
  --info=progress2 \
  --link-dest="$link_dir"  \
  "${exclude_dirs[@]/#/--exclude=}" \
  "${source_dirs[@]}" \
  "$destination_dir" \
|| err=$?

sync

mount_dir="$(df -P "$destination_dir" | tail -1 | cut -d\  -f 1)"
echo "The copy is complete (exit status=$err). Execute '#udisksctl unmount -b \"$mount_dir\" && udisksctl power-off -b \"$mount_dir\"' to remove the destination device."
exit $err
