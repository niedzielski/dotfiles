#!/usr/bin/env bash
# ------------------------------------------------------------------------------
# .bashrc_udev
# Copyright 2012 Stephen Niedzielski. Licensed under GPLv3.

# ------------------------------------------------------------------------------
# $1 - VID[:PID]
usb_id_to_bind()
{
  # HACK: there's gotta be away to get all this info cleanly from udev(adm).
  declare -r dev_name="$(lsusb|sed -rn 's_^Bus ([0-9]{3}) Device ([0-9]{3}): ID '"$1"'.*_/dev/bus/usb/\1/\2_p')"
  declare -r dev_path="$(udevadm info -q path -n"$dev_name")"
  
  basename "$dev_path"
}

usb_unbind()
{
  echo "$(usb_id_to_bind "$@")"|sudo tee /sys/bus/usb/drivers/usb/unbind
}

usb_bind()
{
  echo "$(usb_id_to_bind "$@")"|sudo tee /sys/bus/usb/drivers/usb/bind
}

# ------------------------------------------------------------------------------
# Power cycles the embedded webcam on my System76 Gazelle Professional laptop,
# which malfunctions regularly. Since it's builtin, I can't cycle the cable
# manually and the bus and port stay the same (2-1.6).
# TODO: how to unbind /sys/bus/usb/drivers/uvcvideo/*?
reset_webcam()
{
  echo '2-1.6'|sudo tee /sys/bus/usb/drivers/usb/unbind > /dev/null
  sleep 1
  echo '2-1.6'|sudo tee /sys/bus/usb/drivers/usb/bind  > /dev/null
}
# TODO: reset_usb for when the whole stack tanks.

reset_mouse()
{
  sudo modprobe -r psmouse
  sudo modprobe psmouse
}

# QEMU and some programs trash my USB 3 host controller.
reset_xhci()
{
  ls /sys/bus/pci/drivers/xhci_hcd
  echo '0000:00:14.0'|sudo tee /sys/bus/pci/drivers/xhci_hcd/unbind
  ls /sys/bus/pci/drivers/xhci_hcd
  echo '0000:00:14.0'|sudo tee /sys/bus/pci/drivers/xhci_hcd/bind
  ls /sys/bus/pci/drivers/xhci_hcd
}


__reset_usb_dev()
{
  gccsh "$@" <<EOF
#include <stdio.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <linux/usbdevice_fs.h>

int main(int argc, char ** argv)
{
  int ret = ~0;
  const char * filename = 0;
  int fd = 0;

  if (!argc)
  {
    ret = -2;
    goto ret;
  }
  filename = argv[1];

  fd = open(filename, O_WRONLY);
  if (fd <= 0)
  {
    ret = -3;
    goto ret;
  }

  ret = ioctl(fd, USBDEVFS_RESET, 0);
  if (ret)
  {
    fprintf(stderr, "ioctl failed.\n");
    goto ret;
  }

  ret = close(fd);
  if (ret)
  {
    fprintf(stderr, "close failed.\n");
    goto ret;
  }

  ret:
  if (ret)
  {
    fprintf(stderr,
      "%s:%u ret %d, errno %d, strerror %s\n",
      __FUNCTION__,
      __LINE__,
      ret,
      errno,
      strerror(errno));
  }
  return ret;
}
EOF
}
reset_usb_dev()
{
  sudo __reset_usb_dev "$@"
}
